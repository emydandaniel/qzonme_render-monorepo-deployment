import React, { useState, useRef, useEffect } from "react";
import { useLocation } from "wouter";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { generateAccessCode, generateUrlSlug, generateDashboardToken } from "@/lib/utils";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { AlertCircle, Image, Loader2, X, Eye, Sparkles, CheckCircle } from "lucide-react";
import MultipleChoiceEditor from "./MultipleChoiceEditorNew";
import QuestionList from "./QuestionList";
import AdPlaceholder from "../common/AdPlaceholder";
// Remove Layout import to prevent duplicate headers/footers
import { Question } from "@shared/schema";
import { validateQuiz } from "@/lib/quizUtils";

const QuizCreation: React.FC = () => {
  // Creator name from homepage (stored in sessionStorage)
  const [creatorName, setCreatorName] = useState("");
  
  // UI navigation and toast
  const [, navigate] = useLocation();
  const { toast } = useToast();
  
  // Question state
  const [questionText, setQuestionText] = useState("");
  const [options, setOptions] = useState<string[]>(["", "", "", ""]);
  const [correctOption, setCorrectOption] = useState<number>(0);
  
  // Image handling for questions
  const [questionImage, setQuestionImage] = useState<File | null>(null);
  const [questionImagePreview, setQuestionImagePreview] = useState<string | null>(null);
  const [editingImageUrl, setEditingImageUrl] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  // Collection of questions for this quiz - start empty, load in effect
  const [questions, setQuestions] = useState<Question[]>([]);
  
  // Track whether questions came from auto-generation
  const [isAutoGenerated, setIsAutoGenerated] = useState(false);
  
  // Track which AI-generated questions have been reviewed (for monetization)
  const [reviewedQuestions, setReviewedQuestions] = useState<Set<number>>(() => new Set());
  
  // Check if this quiz requires review (came from AI generation)
  const [requiresReview, setRequiresReview] = useState(false);
  
  // Auto-create mode with sequential review
  const [isAutoCreateMode, setIsAutoCreateMode] = useState(false);
  
  // Auto-create sequential review state
  const [currentAutoReviewIndex, setCurrentAutoReviewIndex] = useState(0);
  const [isInAutoReviewMode, setIsInAutoReviewMode] = useState(false);
  
  // Track which question is being edited (for regular editing, not auto-review)
  const [editingQuestionIndex, setEditingQuestionIndex] = useState<number | null>(null);

    // Initialize auto-create mode and review flags from sessionStorage
  React.useEffect(() => {
    console.log('üöÄ QUIZ EDITOR: Component mounted - starting sessionStorage debug...');
    
    const autoCreateMode = sessionStorage.getItem('autoCreateMode') === 'true';
    const requiresReviewFlag = sessionStorage.getItem('requiresReview') === 'true';
    const hasGeneratedQuestions = !!sessionStorage.getItem('generatedQuestions');
    const generatedQuestionsRaw = sessionStorage.getItem('generatedQuestions');
    const generationMetadataRaw = sessionStorage.getItem('generationMetadata');
    
    console.log('üîç QUIZ EDITOR: === FULL SESSIONSTORAGE DEBUG ===');
    console.log('üîç QUIZ EDITOR: autoCreateMode =', autoCreateMode);
    console.log('üîç QUIZ EDITOR: requiresReview =', requiresReviewFlag);
    console.log('üîç QUIZ EDITOR: hasGeneratedQuestions =', hasGeneratedQuestions);
    console.log('üîç QUIZ EDITOR: generatedQuestions length =', generatedQuestionsRaw?.length || 0);
    console.log('üîç QUIZ EDITOR: generationMetadata length =', generationMetadataRaw?.length || 0);
    console.log('üîç QUIZ EDITOR: All sessionStorage keys:', Object.keys(sessionStorage));
    
    if (generatedQuestionsRaw) {
      try {
        const parsedQuestions = JSON.parse(generatedQuestionsRaw);
        console.log('üîç QUIZ EDITOR: Successfully parsed questions count:', parsedQuestions?.length || 0);
        console.log('üîç QUIZ EDITOR: First question sample:', parsedQuestions?.[0]);
      } catch (e) {
        console.error('‚ùå QUIZ EDITOR: Failed to parse generatedQuestions:', e);
      }
    }
    
    // Only set auto-create mode if ALL conditions are met
    const shouldActivateAutoCreate = autoCreateMode && requiresReviewFlag && hasGeneratedQuestions;
    
    console.log('üéØ QUIZ EDITOR: Activation decision - shouldActivateAutoCreate =', shouldActivateAutoCreate);
    console.log('üéØ QUIZ EDITOR: Setting isAutoCreateMode =', shouldActivateAutoCreate);
    console.log('üéØ QUIZ EDITOR: Setting requiresReview =', shouldActivateAutoCreate);
    
    setIsAutoCreateMode(shouldActivateAutoCreate);
    setRequiresReview(shouldActivateAutoCreate);
    
    if (!shouldActivateAutoCreate && (autoCreateMode || requiresReviewFlag)) {
      // Clear stale flags if conditions aren't met
      console.log('üßπ QUIZ EDITOR: Clearing stale auto-create flags - conditions not met');
      sessionStorage.removeItem('autoCreateMode');
      sessionStorage.removeItem('requiresReview');
      sessionStorage.removeItem('generatedQuestions');
      sessionStorage.removeItem('generationMetadata');
      
      // Also clear any auto-generated questions from the component state
      if (questions.length > 0 && isAutoGenerated) {
        console.log('üßπ QUIZ EDITOR: Clearing auto-generated questions from state');
        setQuestions([]);
        setIsAutoGenerated(false);
        setIsInAutoReviewMode(false);
        setCurrentAutoReviewIndex(0);
      }
    }
  }, []);

  // Load auto-generated questions from session storage
  React.useEffect(() => {
    console.log('ÔøΩ QUIZ EDITOR: Second useEffect triggered - checking for auto-generated questions...');
    console.log('üîç QUIZ EDITOR: isAutoCreateMode =', isAutoCreateMode);
    console.log('üîç QUIZ EDITOR: requiresReview =', requiresReview);
    
    const generatedQuestions = sessionStorage.getItem('generatedQuestions');
    const generationMetadata = sessionStorage.getItem('generationMetadata');
    
    console.log('üîç QUIZ EDITOR: generatedQuestions exists =', !!generatedQuestions);
    console.log('üîç QUIZ EDITOR: generationMetadata exists =', !!generationMetadata);
    console.log('üîç QUIZ EDITOR: generatedQuestions raw data length =', generatedQuestions?.length || 0);
    
    // Only activate auto-review if BOTH auto-create mode is true AND generated questions exist
    const shouldLoadAutoQuestions = isAutoCreateMode && requiresReview && generatedQuestions;
    console.log('üéØ QUIZ EDITOR: Should load auto questions =', shouldLoadAutoQuestions);
    
    if (shouldLoadAutoQuestions) {
      try {
        console.log('üîç QuizEditor: Loading auto-generated questions...');
        const parsedQuestions = JSON.parse(generatedQuestions);
        
        if (Array.isArray(parsedQuestions) && parsedQuestions.length > 0) {
          console.log('‚úÖ QuizEditor: Loading', parsedQuestions.length, 'auto-generated questions');
          
          const formattedQuestions = parsedQuestions.map((q: any, index: number) => ({
            ...q,
            id: q.id || (Date.now() + index),
            order: q.order || (index + 1),
            // Mark AI-generated questions as such (not user-generated)
            isUserGenerated: false
          }));
          
          setQuestions(formattedQuestions);
          setIsAutoGenerated(true);
          setIsInAutoReviewMode(true);
          setCurrentAutoReviewIndex(0);
          
          // Load the first question into the form for review
          const firstQuestion = formattedQuestions[0];
          console.log('üîç QuizEditor: Loading first AI question into form for review:', firstQuestion);
          console.log('üîç QuizEditor: Question text:', firstQuestion.text);
          console.log('üîç QuizEditor: Question options:', firstQuestion.options);
          console.log('üîç QuizEditor: Question correctAnswers:', firstQuestion.correctAnswers);
          
          setQuestionText(firstQuestion.text);
          setOptions([...(firstQuestion.options as string[])]);
          
          // Find and set the correct answer automatically
          const correctAnswerText = (firstQuestion.correctAnswers as string[])?.[0];
          const correctIndex = (firstQuestion.options as string[]).findIndex((opt: string) => opt === correctAnswerText);
          setCorrectOption(correctIndex >= 0 ? correctIndex : 0);
          
          console.log('üîç QuizEditor: Set form data - Text:', firstQuestion.text);
          console.log('üîç QuizEditor: Set form data - Options:', firstQuestion.options);
          console.log('üîç QuizEditor: Set form data - Correct index:', correctIndex);
          
          // Clear auto-review tracking - questions need to be reviewed individually
          setReviewedQuestions(new Set());
          
          toast({
            title: "Review Mode Active",
            description: `Starting review of ${formattedQuestions.length} AI-generated questions. Review question 1 of ${formattedQuestions.length}.`,
            variant: "default"
          });
          
          console.log('‚úÖ QuizEditor: Auto-review mode activated');
        }
      } catch (e) {
        console.error('‚ùå QuizEditor: Error loading auto-generated questions:', e);
        toast({
          title: "Error Loading Questions",
          description: `Error: ${e}`,
          variant: "destructive"
        });
      }
    } else if (!isAutoCreateMode) {
      // For manual creation, only load saved questions if they're not from auto-generation
      try {
        const savedQuestions = localStorage.getItem('qzonme_draft_questions');
        const savedMetadata = localStorage.getItem('qzonme_draft_metadata');
        
        if (savedQuestions) {
          const parsedQuestions = JSON.parse(savedQuestions);
          let shouldLoadSavedQuestions = false;
          
          // Check if we have metadata indicating these are legitimate manual questions
          if (savedMetadata) {
            try {
              const metadata = JSON.parse(savedMetadata);
              // Only load if they were created manually (not auto-generated)
              shouldLoadSavedQuestions = metadata.source === 'manual' && Array.isArray(parsedQuestions) && parsedQuestions.length > 0;
            } catch (e) {
              console.log('‚ùå QuizEditor: Invalid saved metadata, treating as suspicious');
              shouldLoadSavedQuestions = false;
            }
          } else {
            // No metadata means we can't trust the source - could be old auto-generated questions
            console.log('‚ùå QuizEditor: No metadata for saved questions, skipping load to prevent auto-generated contamination');
            shouldLoadSavedQuestions = false;
          }
          
          if (shouldLoadSavedQuestions) {
            console.log('‚úÖ QuizEditor: Loading', parsedQuestions.length, 'verified manual draft questions');
            setQuestions(parsedQuestions);
          } else {
            // Clear potentially contaminated localStorage data
            console.log('üßπ QuizEditor: Clearing potentially contaminated draft questions');
            localStorage.removeItem('qzonme_draft_questions');
            localStorage.removeItem('qzonme_draft_metadata');
          }
        }
      } catch (e) {
        console.error('‚ùå QuizEditor: Error loading saved questions:', e);
        // Clear corrupted data
        localStorage.removeItem('qzonme_draft_questions');
        localStorage.removeItem('qzonme_draft_metadata');
      }
    }
  }, [isAutoCreateMode, requiresReview, toast]); // Add dependencies
  
  // Get the username directly from session storage once
  React.useEffect(() => {
    // Check both possible keys from session storage
    const username = sessionStorage.getItem("username") || sessionStorage.getItem("userName") || "";
    console.log("Retrieved username from session:", username);
    // Debug: List all session storage keys to verify what's available
    console.log("All session storage items:", 
      Object.keys(sessionStorage).map(key => {
        return { key, value: sessionStorage.getItem(key) };
      })
    );
    
    // Set the creator name from session storage
    setCreatorName(username);
    
    // Make sure we're getting the creator name right
    if (!username) {
      toast({
        title: "Important",
        description: "Please return to the home page and enter your name first",
        variant: "destructive"
      });
    }
  }, [toast]);
  
  // Check for auto-generated questions notification and auto-populate first question (separate effect)
  React.useEffect(() => {
    const generationMetadata = sessionStorage.getItem('generationMetadata');
    
    // Only process auto-generated questions if we're actually in auto-create mode
    if (generationMetadata && questions.length > 0 && isAutoCreateMode && requiresReview) {
      try {
        const metadata = JSON.parse(generationMetadata);
        setIsAutoGenerated(true);
        
        toast({
          title: "Auto-Generated Questions Loaded!",
          description: `${questions.length} questions generated using ${metadata.generationSettings?.difficulty || 'Medium'} difficulty in ${metadata.generationSettings?.language || 'English'}. Scroll down to review and edit questions, or add more above.`,
        });
        
        // Auto-populate the first question in the form for better UX (only in auto-create mode)
        // IMPORTANT: Only do this if NOT in auto-review mode, as auto-review handles its own form loading
        if (questions.length > 0 && !isInAutoReviewMode && !isAutoGenerated) {
          const firstQuestion = questions[0];
          setQuestionText(firstQuestion.text);
          if (firstQuestion.options && Array.isArray(firstQuestion.options)) {
            setOptions([...firstQuestion.options]);
            // Find the correct answer index
            const correctAnswerText = (firstQuestion.correctAnswers as string[])?.[0];
            const correctIndex = (firstQuestion.options as string[]).findIndex((opt: string) => opt === correctAnswerText);
            setCorrectOption(correctIndex >= 0 ? correctIndex : 0);
          }
          if (firstQuestion.imageUrl) {
            setQuestionImagePreview(firstQuestion.imageUrl);
          }
        }
        
        // DON'T clear the metadata yet - we need it for the review workflow
        // sessionStorage.removeItem('generationMetadata'); // REMOVED THIS LINE
      } catch (e) {
        console.error("Error parsing generation metadata:", e);
      }
    }
  }, [questions.length, isAutoCreateMode, requiresReview, isInAutoReviewMode, toast]);

  // Debug: Log questions state
  React.useEffect(() => {
    console.log('üîç QuizEditor: Current questions state:', questions);
    console.log('üîç QuizEditor: Questions length:', questions.length);
    console.log('üîç QuizEditor: Is auto-generated:', isAutoGenerated);
    console.log('üîç QuizEditor: Is in auto-review mode:', isInAutoReviewMode);
    console.log('üîç QuizEditor: Current auto-review index:', currentAutoReviewIndex);
  }, [questions, isAutoGenerated, isInAutoReviewMode, currentAutoReviewIndex]);
  
  // Function to start fresh (clear all existing questions)
  const handleStartFresh = () => {
    console.log('üîÑ Starting fresh - clearing all questions and data');
    
    // Clear all storage
    sessionStorage.removeItem('generatedQuestions');
    sessionStorage.removeItem('autoCreateMetadata');
    sessionStorage.removeItem('requiresReview');
    sessionStorage.removeItem('autoCreateMode');
    sessionStorage.removeItem('generationMetadata');
    localStorage.removeItem('qzonme_draft_questions');
    localStorage.removeItem('qzonme_draft_metadata');
    
    // Reset state
    setQuestions([]);
    setIsAutoGenerated(false);
    setReviewedQuestions(new Set());
    setIsInAutoReviewMode(false);
    setCurrentAutoReviewIndex(0);
    resetForm();
    
    toast({
      title: "Fresh Start",
      description: "All questions cleared. You can now start creating your quiz from scratch.",
      variant: "default"
    });
  };
  
  // Save questions to localStorage whenever they change (only for manual creation)
  useEffect(() => {
    try {
      if (questions.length > 0 && !isAutoCreateMode && !isAutoGenerated) {
        // Only save questions that are manually created, not auto-generated
        localStorage.setItem('qzonme_draft_questions', JSON.stringify(questions));
        
        // Save metadata to indicate these are manually created questions
        const metadata = {
          source: 'manual',
          timestamp: Date.now(),
          creatorName: creatorName
        };
        localStorage.setItem('qzonme_draft_metadata', JSON.stringify(metadata));
        
        console.log("Saved", questions.length, "manual questions to local storage");
      } else if (questions.length === 0) {
        // Clear localStorage when no questions remain
        localStorage.removeItem('qzonme_draft_questions');
        localStorage.removeItem('qzonme_draft_metadata');
      }
    } catch (e) {
      console.error("Error saving questions:", e);
    }
  }, [questions, isAutoCreateMode, isAutoGenerated, creatorName]);
  
  // Ad refresh counter - increments whenever we want to refresh ads
  const [adRefreshCounter, setAdRefreshCounter] = useState(0);
  
  // Minimum required questions indicator
  const requiredQuestionsCount = 5;
  const questionsNeeded = Math.max(0, requiredQuestionsCount - questions.length);
  
  // Image upload mutation
  const uploadImageMutation = useMutation({
    mutationFn: async (file: File) => {
      const formData = new FormData();
      formData.append("image", file);
      
      const response = await fetch("/api/upload-image", {
        method: "POST",
        body: formData
      });
      
      if (!response.ok) {
        throw new Error("Failed to upload image");
      }
      
      return response.json();
    }
  });

  // Create quiz mutation
  const createQuizMutation = useMutation({
    mutationFn: async () => {
      // Validate quiz creator exists
      if (!creatorName) {
        toast({
          title: "Missing Creator",
          description: "Please go back to the homepage and enter your name",
          variant: "destructive"
        });
        throw new Error("Creator name is missing");
      }
      
      // Validate quiz has enough questions
      if (questions.length < requiredQuestionsCount) {
        toast({
          title: "More Questions Needed",
          description: `Please add ${questionsNeeded} more question(s)`,
          variant: "destructive"
        });
        throw new Error("Not enough questions");
      }
      
      // Get user ID from session
      const currentUserId = parseInt(sessionStorage.getItem("userId") || "0");
      
      console.log(`Creating quiz with name: "${creatorName}" (ensuring fresh data)`);
      
      // Generate fresh tokens and codes
      const accessCode = generateAccessCode();
      const dashboardToken = generateDashboardToken();
      
      // Important: Force a fresh slug creation with the current name to avoid cache issues
      // Clear any old creatorName data from localStorage (if any) as a safety measure
      localStorage.removeItem("creatorName");
      
      // Generate the URL slug with the current creator name
      const urlSlug = generateUrlSlug(creatorName);
      
      // Store the current dashboard token in sessionStorage for immediate access
      sessionStorage.setItem("currentQuizDashboardToken", dashboardToken);
      
      // Create the quiz
      const quizResponse = await apiRequest("POST", "/api/quizzes", {
        creatorId: currentUserId,
        creatorName: creatorName,
        accessCode,
        urlSlug,
        dashboardToken
      });
      
      if (!quizResponse.ok) {
        throw new Error("Failed to create quiz");
      }
      
      const quiz = await quizResponse.json();
      
      console.log(`Quiz created successfully with ID: ${quiz.id}`);
      console.log(`Quiz ID type: ${typeof quiz.id}`);
      console.log(`Quiz ID value: ${quiz.id}`);
      console.log(`Dashboard Token: ${quiz.dashboardToken}`);
      console.log(`URL Slug: ${quiz.urlSlug}`);
      
      // Create all questions for the quiz
      const questionPromises = questions.map((question, index) => {
        // Transform AI generated format to database format
        // Handle both AI format (correctAnswer: "A") and manual format (correctAnswers: ["text"])
        // Cast to any to handle different question formats from AI vs manual creation
        const aiQuestion = question as any;
        let correctAnswerText;
        
        if (aiQuestion.correctAnswer && typeof aiQuestion.correctAnswer === 'string' && aiQuestion.correctAnswer.length > 0) {
          // AI generated format - convert letter to index
          const correctAnswerIndex = aiQuestion.correctAnswer.charCodeAt(0) - 'A'.charCodeAt(0);
          const options = Array.isArray(aiQuestion.options) ? aiQuestion.options : [];
          if (correctAnswerIndex >= 0 && correctAnswerIndex < options.length) {
            correctAnswerText = options[correctAnswerIndex];
          } else {
            console.warn(`Invalid correctAnswer index: ${correctAnswerIndex} for question: ${aiQuestion.question || aiQuestion.text}`);
            correctAnswerText = options.length > 0 ? options[0] : "Option A"; // Fallback to first option
          }
        } else if (aiQuestion.correctAnswers && Array.isArray(aiQuestion.correctAnswers) && aiQuestion.correctAnswers.length > 0) {
          // Manual format - already has correct answer text
          correctAnswerText = aiQuestion.correctAnswers[0];
        } else {
          // Fallback - use first option
          console.warn(`No valid correctAnswer found for question: ${aiQuestion.question || aiQuestion.text}. Using first option as fallback.`);
          const options = Array.isArray(aiQuestion.options) ? aiQuestion.options : [];
          correctAnswerText = options.length > 0 ? options[0] : "Option A";
        }
        
        const transformedQuestion = {
          quizId: quiz.id,
          text: aiQuestion.question || aiQuestion.text || "Question text", // Handle both AI and manual formats
          type: "multiple-choice",
          options: Array.isArray(aiQuestion.options) ? aiQuestion.options : [], // Ensure it's an array
          correctAnswers: [correctAnswerText], // Convert letter to actual answer text
          hint: aiQuestion.explanation || aiQuestion.hint || null, // Handle both explanation and hint fields
          order: index,
          imageUrl: aiQuestion.imageUrl || null
        };
        
        console.log(`Creating question ${index + 1} with quizId: ${quiz.id} (type: ${typeof quiz.id})`);
        console.log('Question data:', transformedQuestion);
        
        return apiRequest("POST", "/api/questions", transformedQuestion);
      });
      
      console.log("Creating questions...", questionPromises.length);
      const questionResults = await Promise.all(questionPromises);
      console.log("All questions created successfully:", questionResults.length);
      return quiz;
    }
  });

  // Handle adding a new question
  const handleAddQuestion = async () => {
    // Validate question has text
    if (!questionText.trim()) {
      toast({
        title: "Question Required",
        description: "Please enter a question",
        variant: "destructive"
      });
      return;
    }
    
    // Validate all options are filled
    if (options.some(opt => !opt.trim())) {
      toast({
        title: "Options Required",
        description: "Please fill in all options",
        variant: "destructive"
      });
      return;
    }

    try {
      // Handle image upload if present
      let imageUrl = null;
      
      // Use the existing image URL if we're editing a question
      if (editingImageUrl) {
        console.log("Using existing image URL from edit:", editingImageUrl);
        imageUrl = editingImageUrl;
      }
      // Otherwise, upload the new image if one is selected
      else if (questionImage) {
        try {
          const uploadResult = await uploadImageMutation.mutateAsync(questionImage);
          imageUrl = uploadResult.imageUrl;
        } catch (error) {
          console.error("Failed to upload image:", error);
          toast({
            title: "Image Upload Failed",
            description: "Your question will be added without the image",
            variant: "destructive"
          });
        }
      }

      // Prepare the correct answers array
      const correctAnswers = [options[correctOption]];

      if (editingQuestionIndex !== null) {
        // Update existing question
        const updatedQuestion: Question = {
          ...questions[editingQuestionIndex],
          text: questionText,
          options,
          correctAnswers,
          imageUrl: imageUrl || questions[editingQuestionIndex].imageUrl // Preserve existing image if no new one uploaded
        };

        const updatedQuestions = [...questions];
        updatedQuestions[editingQuestionIndex] = updatedQuestion;
        setQuestions(updatedQuestions);
        
        // Clear editing state
        setEditingQuestionIndex(null);
        
        toast({
          title: "Question Updated",
          description: `Question ${editingQuestionIndex + 1} has been updated`,
          variant: "default"
        });
      } else {
        // Create new question - mark it as user-generated (not needing review)
        const newQuestion: Question = {
          id: Date.now(), // Temporary ID until saved to server
          quizId: 0, // Will be set when quiz is created
          text: questionText,
          type: "multiple-choice",
          options,
          correctAnswers,
          hint: null,
          order: questions.length,
          imageUrl
        };

        // Add to questions collection
        setQuestions(prev => [...prev, newQuestion]);
        
        // Automatically mark user-generated questions as reviewed since they don't need review
        setReviewedQuestions(prev => new Set([...Array.from(prev), newQuestion.id]));
        
        toast({
          title: "Question Added",
          description: `${questions.length + 1} of ${requiredQuestionsCount} questions added`,
          variant: "default"
        });
      }
      
      // Increment ad refresh counter to reload ads
      setAdRefreshCounter(prev => prev + 1);
      
      // Reset form for next question
      resetForm();
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to add question",
        variant: "destructive"
      });
    }
  };

  // Handle sequential review of auto-generated questions
  const handleNextAutoReview = async () => {
    if (!isInAutoReviewMode) {
      // Not in auto-review mode, use normal add question logic
      return handleAddQuestion();
    }

    // Mark the current question as reviewed
    const currentQuestion = questions[currentAutoReviewIndex];
    setReviewedQuestions(prev => new Set([...Array.from(prev), currentQuestion.id]));

    // Update the current question being reviewed with any edits (but don't duplicate)
    if (editingQuestionIndex === currentAutoReviewIndex) {
      const updatedQuestion = {
        ...questions[currentAutoReviewIndex],
        text: questionText,
        options: [...options],
        correctAnswers: [options[correctOption]]
      };

      // Update the question in the list
      const updatedQuestions = [...questions];
      updatedQuestions[currentAutoReviewIndex] = updatedQuestion;
      setQuestions(updatedQuestions);
      
      // Clear editing state
      setEditingQuestionIndex(null);
    }

    // Move to next question or complete review
    const nextIndex = currentAutoReviewIndex + 1;
    
    if (nextIndex < questions.length) {
      // Load next question for review
      setCurrentAutoReviewIndex(nextIndex);
      const nextQuestion = questions[nextIndex];
      
      setQuestionText(nextQuestion.text);
      setOptions([...(nextQuestion.options as string[])]);
      
      // Auto-select correct answer
      const correctAnswerText = (nextQuestion.correctAnswers as string[])?.[0];
      const correctIndex = (nextQuestion.options as string[]).findIndex(opt => opt === correctAnswerText);
      setCorrectOption(correctIndex >= 0 ? correctIndex : 0);
      
      console.log(`üîç Auto-review Q${nextIndex + 1}: Correct answer is "${correctAnswerText}" at index ${correctIndex}`);
      
      // Clear any selected image
      setQuestionImage(null);
      setEditingImageUrl(nextQuestion.imageUrl || null);
      
      toast({
        title: "Next Question",
        description: `Reviewing question ${nextIndex + 1} of ${questions.length}`,
        variant: "default"
      });
    } else {
      // Review complete - COMPLETELY exit review mode and clear form
      setIsInAutoReviewMode(false);
      setCurrentAutoReviewIndex(0);
      setEditingQuestionIndex(null); // Clear any editing state
      
      // IMPORTANT: Clear the requiresReview flag since review is now complete
      setRequiresReview(false);
      
      // Clear auto-create mode flags from sessionStorage since review is done
      sessionStorage.removeItem('autoCreateMode');
      sessionStorage.removeItem('requiresReview');
      sessionStorage.removeItem('generatedQuestions');
      sessionStorage.removeItem('generationMetadata');
      
      // Force a complete form reset
      setQuestionText("");
      setOptions(["", "", "", ""]);
      setCorrectOption(0);
      setQuestionImage(null);
      setEditingImageUrl(null);
      if (questionImagePreview) {
        URL.revokeObjectURL(questionImagePreview);
        setQuestionImagePreview(null);
      }
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      
      console.log("üèÅ Review completed - form cleared and ready for new questions");
      
      toast({
        title: "Review Complete!",
        description: `All ${questions.length} questions have been reviewed. The form is now ready for adding new questions.`,
        variant: "default"
      });
    }
  };

  // Handle image selection
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      if (file.size > 10 * 1024 * 1024) { // 10MB limit
        toast({
          title: "File Too Large",
          description: "Image must be less than 10MB",
          variant: "destructive"
        });
        return;
      }
      
      setQuestionImage(file);
      const imageUrl = URL.createObjectURL(file);
      setQuestionImagePreview(imageUrl);
    }
  };
  
  // Handle removing an image
  const handleRemoveImage = () => {
    setQuestionImage(null);
    if (questionImagePreview) {
      URL.revokeObjectURL(questionImagePreview);
      setQuestionImagePreview(null);
    }
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // Reset form fields
  const resetForm = () => {
    setQuestionText("");
    setOptions(["", "", "", ""]);
    setCorrectOption(0);
    setEditingImageUrl(null); // Clear the editing image URL
    setEditingQuestionIndex(null); // Clear editing state
    setQuestionImage(null); // Clear any uploaded images
    
    // Clear auto-review mode completely when reset is called
    setIsInAutoReviewMode(false);
    setCurrentAutoReviewIndex(0);
    
    console.log("üîÑ Form reset - cleared all states including auto-review mode");
    
    if (questionImagePreview) {
      URL.revokeObjectURL(questionImagePreview);
      setQuestionImagePreview(null);
    }
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };


  
  // Edit existing question
  const handleEditQuestion = (index: number) => {
    const question = questions[index];
    
    // Completely exit auto-review mode when editing any question
    if (isInAutoReviewMode) {
      setIsInAutoReviewMode(false);
      setCurrentAutoReviewIndex(0);
      
      console.log("üîÑ Exited auto-review mode to edit question", index + 1);
      
      toast({
        title: "Editing Mode",
        description: "Exited sequential review to edit this question. You can continue reviewing later.",
        variant: "default"
      });
    }
    
    // Mark this question as reviewed (for AI-generated quizzes)
    if (requiresReview) {
      setReviewedQuestions(prev => new Set([...Array.from(prev), question.id]));
      console.log(`üìù Question ${question.id} marked as reviewed (edited)`);
    }
    
    // Set editing state to prevent duplication
    setEditingQuestionIndex(index);
    
    // Set the question text
    setQuestionText(question.text);
    
    // Set the options and correct answer (clean the options if they have letter prefixes)
    if (question.options) {
      const cleanOptions = (question.options as string[]).map(opt => {
        // Remove A), B), C), D) prefixes if they exist
        return opt.replace(/^[A-D]\)\s*/, '').trim();
      });
      setOptions(cleanOptions);
      
      const correctAnswerText = (question.correctAnswers as string[])?.[0];
      const cleanCorrectAnswer = correctAnswerText?.replace(/^[A-D]\)\s*/, '').trim();
      const correctIndex = cleanOptions.findIndex(opt => opt === cleanCorrectAnswer);
      setCorrectOption(correctIndex >= 0 ? correctIndex : 0);
    }
    
    // Handle the image
    if (question.imageUrl) {
      setQuestionImagePreview(question.imageUrl);
      // Save the image URL separately so we can use it when updating the question
      setEditingImageUrl(question.imageUrl);
      console.log("Editing question with image URL:", question.imageUrl);
    } else {
      setQuestionImagePreview(null);
      setEditingImageUrl(null);
    }
    
    // Store the index of the question being edited instead of removing it
    setEditingQuestionIndex(index);
    
    // Scroll to the form
    document.querySelector('.question-container')?.scrollIntoView({ behavior: 'smooth' });
  };

  // Delete a question
  const handleDeleteQuestion = (index: number) => {
    const updatedQuestions = [...questions];
    updatedQuestions.splice(index, 1);
    setQuestions(updatedQuestions);
  };

  // Mark question as reviewed without editing (for AI-generated questions)
  const handleMarkAsReviewed = (index: number) => {
    const question = questions[index];
    if (requiresReview) {
      setReviewedQuestions(prev => new Set([...Array.from(prev), question.id]));
      console.log(`‚úÖ Question ${question.id} marked as reviewed (viewed)`);
      
      toast({
        title: "Question Reviewed",
        description: `Question ${index + 1} marked as reviewed`,
        variant: "default"
      });
    }
  };

  // Check if all AI-generated questions have been reviewed
  const areAllQuestionsReviewed = () => {
    if (!requiresReview) return true; // No review required for manual quizzes
    
    // Only check AI-generated questions (not user-added ones)
    const aiGeneratedQuestions = questions.filter(q => !(q as any).isUserGenerated);
    const aiQuestionIds = aiGeneratedQuestions.map(q => q.id);
    
    // If there are no AI-generated questions, review is complete
    if (aiQuestionIds.length === 0) return true;
    
    return aiQuestionIds.every(id => reviewedQuestions.has(id));
  };

  // Get count of unreviewed questions (only AI-generated ones)
  const getUnreviewedCount = () => {
    if (!requiresReview) return 0;
    
    // Only count AI-generated questions that need review
    const aiGeneratedQuestions = questions.filter(q => !(q as any).isUserGenerated);
    const aiQuestionIds = aiGeneratedQuestions.map(q => q.id);
    return aiQuestionIds.filter(id => !reviewedQuestions.has(id)).length;
  };

  // Finish quiz creation
  const handleFinishQuiz = async () => {
    // Check if review is required and not completed
    if (requiresReview && !areAllQuestionsReviewed()) {
      const unreviewed = getUnreviewedCount();
      toast({
        title: "Review Required",
        description: `Please review all ${unreviewed} remaining AI-generated questions before submitting your quiz.`,
        variant: "destructive"
      });
      return;
    }

    try {
      console.log("Starting quiz creation process...");
      const quiz = await createQuizMutation.mutateAsync();
      console.log("Quiz created successfully:", quiz);
      
      // Clear the saved questions from localStorage once quiz is created successfully
      localStorage.removeItem('qzonme_draft_questions');
      localStorage.removeItem('qzonme_draft_metadata');
      // Clear review requirement and auto-create flags
      sessionStorage.removeItem('requiresReview');
      sessionStorage.removeItem('autoCreateMode');
      sessionStorage.removeItem('generationMetadata');
      console.log("Cleared draft questions from local storage after successful quiz creation");
      
      toast({
        title: "Quiz Created!",
        description: "Your quiz has been created successfully",
        variant: "default"
      });
      
      // Store quiz data in sessionStorage for immediate access by ShareQuizPage
      // This matches the old working version's approach
      sessionStorage.setItem("currentQuizId", quiz.id.toString());
      sessionStorage.setItem("currentQuizAccessCode", quiz.accessCode);
      sessionStorage.setItem("currentQuizUrlSlug", quiz.urlSlug);
      sessionStorage.setItem("currentQuizDashboardToken", quiz.dashboardToken);
      sessionStorage.setItem("createdQuizData", JSON.stringify(quiz));
      console.log("Stored quiz data in sessionStorage:", {
        id: quiz.id,
        accessCode: quiz.accessCode,
        urlSlug: quiz.urlSlug
      });
      
      // Navigate to share page
      console.log(`Navigating to share page: /share/${quiz.id}`);
      navigate(`/share/${quiz.id}`);
    } catch (error) {
      console.error("Failed to create quiz:", error);
      toast({
        title: "Failed to create quiz",
        description: error instanceof Error ? error.message : "Please try again",
        variant: "destructive"
      });
    }
  };

  return (
    <>
      <h1 className="text-3xl font-bold mb-4 text-primary">
        {isInAutoReviewMode ? `Review Question ${currentAutoReviewIndex + 1} of ${questions.length}` 
         : isAutoGenerated && questions.length > 0 ? "Review & Edit Your Quiz" 
         : "Create Your Quiz"}
      </h1>
      
      {/* Start Fresh Option (only show if there are existing questions) */}
      {questions.length > 0 && (
        <div className="mb-4 flex justify-end">
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleStartFresh}
            className="text-red-600 hover:text-red-700 hover:border-red-300"
          >
            Start Fresh
          </Button>
        </div>
      )}
      
      {/* Consolidated Auto-Create/Review Mode Info */}
      {(isInAutoReviewMode || (isAutoGenerated && questions.length > 0) || requiresReview) && (
        <Alert className="mb-6 border-blue-200 bg-blue-50">
          <Sparkles className="h-4 w-4 text-blue-600" />
          <AlertTitle className="text-blue-800">
            {isInAutoReviewMode ? `üìù Auto-Review Mode: Question ${currentAutoReviewIndex + 1} of ${questions.length}` : "Questions Auto-Generated!"}
          </AlertTitle>
          <AlertDescription className="text-blue-700 space-y-2">
            {isInAutoReviewMode ? (
              <div>
                <div className="font-medium mb-1">
                  Review and edit this AI-generated question, then click "Next Question" to continue.
                </div>
                <div className="text-sm">
                  The correct answer is automatically selected (orange radio button).
                </div>
              </div>
            ) : (
              <div>
                ‚úÖ {questions.length} questions have been generated below. You can edit them, add more questions using the form, or remove any you don't want.
              </div>
            )}
            {requiresReview && (
              <div className="pt-2 border-t border-blue-200">
                <div className="flex items-center gap-2 text-yellow-700">
                  <Eye className="h-4 w-4" />
                  <span className="font-medium">Review Required:</span>
                </div>
                <div className="text-yellow-700 text-sm mt-1">
                  Progress: {reviewedQuestions.size} of {questions.length} questions reviewed
                  {!areAllQuestionsReviewed() && ` (${getUnreviewedCount()} remaining)`}
                </div>
              </div>
            )}
          </AlertDescription>
        </Alert>
      )}
      
      {/* Requirements Alert */}
      <Alert className="mb-6">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Important</AlertTitle>
        <AlertDescription>
          Your quiz requires at least {requiredQuestionsCount} questions. You have {questions.length} so far.
          {questions.length < requiredQuestionsCount && ` Please add ${questionsNeeded} more.`}
        </AlertDescription>
      </Alert>
      
      <Card className="mb-6">
        <CardHeader className="pb-3">
          <CardTitle className="text-lg">
            {isInAutoReviewMode ? 
              `Review Question ${currentAutoReviewIndex + 1} of ${questions.length}` :
              editingQuestionIndex !== null ?
                `Edit Question ${editingQuestionIndex + 1}` :
                isAutoGenerated && questions.length > 0 ? 
                  "Edit Questions or Add More" : 
                  "Create Question"
            }
          </CardTitle>
          {editingQuestionIndex !== null && (
            <CardDescription>
              You are editing question {editingQuestionIndex + 1}. Make your changes and click "Update Question" to save, or "Cancel" to discard changes.
            </CardDescription>
          )}
          {isAutoGenerated && questions.length > 0 && editingQuestionIndex === null && !isInAutoReviewMode && (
            <CardDescription>
              Edit any generated question by clicking the pencil icon, or add new questions using the form below.
            </CardDescription>
          )}
        </CardHeader>
        <CardContent className="pt-0">
          {/* Question Editor */}
          <div className="question-container">
            <div className="mb-4">
              <Label htmlFor="question-text" className="block text-sm font-medium mb-1">
                Question
              </Label>
              <input
                type="text"
                id="question-text"
                className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                placeholder="Ask something about yourself..."
                value={questionText}
                onChange={(e) => setQuestionText(e.target.value)}
              />
            </div>
            
            {/* Image upload area */}
            <div className="mb-6">
              <Label className="block text-sm font-medium mb-2">
                Question Image (Optional)
              </Label>
              
              {questionImagePreview ? (
                <div className="relative w-full h-40 bg-gray-100 rounded-md overflow-hidden mb-2">
                  <img 
                    src={questionImagePreview} 
                    alt="Question preview" 
                    className="w-full h-full object-contain"
                  />
                  <button
                    type="button"
                    onClick={handleRemoveImage}
                    className="absolute top-2 right-2 bg-red-500 text-white p-1 rounded-full"
                    aria-label="Remove image"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
              ) : (
                <div 
                  className="border-2 border-dashed border-gray-300 rounded-md p-6 text-center cursor-pointer hover:border-primary transition-colors mb-2"
                  onClick={() => fileInputRef.current?.click()}
                >
                  <div className="flex flex-col items-center">
                    <Image className="h-8 w-8 text-gray-400 mb-2" />
                    <p className="text-sm font-medium text-gray-600 mb-1">Click to upload an image</p>
                    <p className="text-xs text-gray-500">PNG, JPG or GIF (max. 10MB)</p>
                  </div>
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    className="hidden"
                    onChange={handleImageChange}
                  />
                </div>
              )}
            </div>
            
            {/* Multiple choice editor */}
            <MultipleChoiceEditor
              options={options}
              setOptions={setOptions}
              correctOption={correctOption}
              setCorrectOption={setCorrectOption}
            />
          </div>
          
          <div className="flex gap-3 mt-6">
            <Button 
              type="button" 
              className="flex-1" 
              onClick={handleNextAutoReview}
              disabled={uploadImageMutation.isPending}
            >
              {uploadImageMutation.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Uploading...
                </>
              ) : isInAutoReviewMode ? (
                currentAutoReviewIndex === questions.length - 1 ? "Complete Review" : `Next Question (${currentAutoReviewIndex + 1}/${questions.length})`
              ) : editingQuestionIndex !== null ? (
                "Update Question"
              ) : isAutoGenerated && questions.length > 0 ? (
                "Add Another Question"
              ) : (
                questions.length > 0 ? "Add Question" : "Add First Question"
              )}
            </Button>
            
            {editingQuestionIndex !== null && !isInAutoReviewMode && (
              <Button 
                type="button" 
                variant="outline"
                onClick={resetForm}
                className="px-4"
              >
                Cancel Edit
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
      
      {/* Questions List */}
      <Card>
        <CardContent className="pt-6">
          <h3 className="font-semibold text-lg mb-3">
            {isAutoGenerated && questions.length > 0 ? 
              `Generated Questions (${questions.length})` : 
              "Your Questions"
            }
          </h3>
          
          <QuestionList 
            questions={questions} 
            onEdit={handleEditQuestion}
            onDelete={handleDeleteQuestion}
            reviewedQuestions={reviewedQuestions}
            requiresReview={requiresReview}
            onMarkAsReviewed={handleMarkAsReviewed}
            isInAutoReviewMode={isInAutoReviewMode}
          />
          
          {/* Finalize and Share section */}
          <div className="mt-6 pt-4 border-t border-gray-200">
            <div className="flex justify-between items-center">
              <span className="text-sm text-muted-foreground">
                {questions.length} of {requiredQuestionsCount} questions added
                {requiresReview && (
                  <span className="block text-yellow-600">
                    Review: {reviewedQuestions.size} of {questions.length} questions reviewed
                  </span>
                )}
              </span>
              <Button
                type="button"
                className={
                  (questions.length >= requiredQuestionsCount && (!requiresReview || areAllQuestionsReviewed())) 
                    ? "btn-primary" 
                    : "opacity-50 cursor-not-allowed"
                }
                disabled={
                  questions.length < requiredQuestionsCount || 
                  createQuizMutation.isPending || 
                  (requiresReview && !areAllQuestionsReviewed())
                }
                onClick={handleFinishQuiz}
              >
                {createQuizMutation.isPending ? "Creating..." : 
                 requiresReview && !areAllQuestionsReviewed() ? `Review ${getUnreviewedCount()} More` :
                 "Finish & Share"}
              </Button>
            </div>
          </div>

          {/* Ad Placeholder with refresh key to ensure ads reload when questions are added */}
          <AdPlaceholder refreshKey={adRefreshCounter} />
        </CardContent>
      </Card>
    </>
  );
};

export default QuizCreation;